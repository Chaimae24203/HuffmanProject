Projet I
La m√©thode de compression Huffman consiste √† diminuer au maximum le
nombre de bits utilis√©s pour coder un fragment d'information par la cr√©ation
de l'arbre de Huffman. Les feuilles de l'arbre correspondent aux lettres de
l'alphabet. Les noeuds interne ne contiennent pas d'information. Le chemin
emprunt√© pour atteindre une feuille depuis la racine d√©nit le code de la
lettre sur cette feuille : √† gauche 0, √† droite 1.
D√©velopper l'algorithme vu en cours permettant, √† l'aide d'un arbre binaire,
d'efectuer une compression des chiers de caract√®res. L'objectif principalest d'obtenir un programme final fonctionnel qui permette de compresser
(√©ventuellement d√©compresser) de l'information.
 D√©finir la structure d'un noeud de l'arbre Human (ex., caract√®re,
fr√©quence, fils gauche et fils droite).
 D√©finir la structure de la collection des noeuds de l'arbre (ou arbre
Huffman), par exemple, le tableau de pointeurs des noeuds.
 La fonction permettant d'allouer un nouveau noeud de tas-min avec
comme param√®tre un caract√®re donn√© et sa fr√©quence.
 La fonction permettant de cr√©er un tas minimum de capacit√© donn√©e.
 La fonction permettant d'√©changer deux noeuds de tas-min.
 La fonction standard entasserMin (similaire √† entasserMax ).
 La fonction standard extraire-Tas-Min permettant d'extraire le noeud
de valeur minimale du tas (similaire √† extraire-Tas-Max ).
 La fonction standard inserer-Tas-Min pour ins√©rer un nouveau noeud
dans un tas min (similaire √† inserer-Tas-Max ).
 La fonction standard permettant de construire un tas min.
 La fonction permettant d'initialiser et cr√©er un tas min.
 La fonction principale qui construit l'arbre Huffman.
 La fonction permettant de construire un arbre Huffman et imprime
les codes en parcourant l'arbre.
 Fonctions permettent d'effectuer des tests et acher les r√©sultats.
 Lecture du texte √† partir d'un fichier source et stockage dans un tableau.
 Calcul de l'alphabet et des fr√©quences.
 Codage et sauvegarde des codes et du texte cod√© dans des fichiers.
 Les fonctions permettant le d√©codage √† partir des codes calcul√©s.
_le voila le code
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TREE_HT 100
#define MAX_CODE_LENGTH 100

// Structure pour un noeud de l'arbre Huffman
typedef struct Node {
    char character;
    int frequency;
    struct Node *left, *right;
} Node;

// Structure pour un tas min
typedef struct MinHeap {
    int size;
    int capacity;
    Node** array;
} MinHeap;

// Fonction pour allouer un nouveau noeud
Node* newNode(char character, int frequency) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->character = character;
    node->frequency = frequency;
    node->left = node->right = NULL;
    return node;
}

// Fonction pour cr√©er un tas min
MinHeap* createMinHeap(int capacity) {
    MinHeap* heap = (MinHeap*)malloc(sizeof(MinHeap));
    heap->size = 0;
    heap->capacity = capacity;
    heap->array = (Node**)malloc(heap->capacity * sizeof(Node*));
    return heap;
}

// Fonction pour √©changer deux noeuds
void swapNodes(Node** a, Node** b) {
    Node* temp = *a;
    *a = *b;
    *b = temp;
}

// Fonction d'entassement min
void minHeapify(MinHeap* heap, int index) {
    int smallest = index;
    int left = 2 * index + 1;
    int right = 2 * index + 2;

    if (left < heap->size && heap->array[left]->frequency < heap->array[smallest]->frequency)
        smallest = left;

    if (right < heap->size && heap->array[right]->frequency < heap->array[smallest]->frequency)
        smallest = right;

    if (smallest != index) {
        swapNodes(&heap->array[smallest], &heap->array[index]);
        minHeapify(heap, smallest);
    }
}

// Fonction pour extraire le noeud minimum
Node* extractMin(MinHeap* heap) {
    Node* temp = heap->array[0];
    heap->array[0] = heap->array[heap->size - 1];
    heap->size--;
    minHeapify(heap, 0);
    return temp;
}

// Fonction pour ins√©rer un noeud dans le tas min
void insertMinHeap(MinHeap* heap, Node* node) {
    heap->size++;
    int i = heap->size - 1;
    while (i && node->frequency < heap->array[(i - 1) / 2]->frequency) {
        heap->array[i] = heap->array[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    heap->array[i] = node;
}

// Fonction pour construire un tas min
void buildMinHeap(MinHeap* heap) {
    int n = heap->size - 1;
    for (int i = (n - 1) / 2; i >= 0; i--)
        minHeapify(heap, i);
}

// Fonction pour construire l'arbre Huffman
Node* buildHuffmanTree(char data[], int freq[], int size) {
    Node *left, *right, *top;

    MinHeap* heap = createMinHeap(size);
    for (int i = 0; i < size; ++i)
        heap->array[i] = newNode(data[i], freq[i]);
    heap->size = size;
    buildMinHeap(heap);

    while (heap->size != 1) {
        left = extractMin(heap);
        right = extractMin(heap);
        top = newNode('$', left->frequency + right->frequency);
        top->left = left;
        top->right = right;
        insertMinHeap(heap, top);
    }
    return extractMin(heap);
}

// Fonction pour afficher les codes en parcourant l'arbre
void printCodes(Node* root, char* code, int top) {
    if (root->left) {
        code[top] = '0';
        printCodes(root->left, code, top + 1);
    }
    if (root->right) {
        code[top] = '1';
        printCodes(root->right, code, top + 1);
    }
    if (!(root->left) && !(root->right)) {
        code[top] = '\0';
        printf("%c: %s\n", root->character, code);
    }
}

// Fonction principale
void HuffmanCodes(char data[], int freq[], int size) {
    Node* root = buildHuffmanTree(data, freq, size);
    char code[MAX_TREE_HT];
    printCodes(root, code, 0);
}

int main() {
    // Exemple de donn√©es : caract√®res et fr√©quences
    char data[] = {'a', 'b', 'c', 'd', 'e', 'f'};
    int freq[] = {5, 9, 12, 13, 16, 45};
    int size = sizeof(data) / sizeof(data[0]);

    printf("Codes Huffman:\n");
    HuffmanCodes(data, freq, size);

    return 0;
}
